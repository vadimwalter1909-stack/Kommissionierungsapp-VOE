Alles klar, Vadim â€” jetzt kann ich dein echtes Dashboard sauber und narrensicher umbauen, weil ich endlich die richtige Datei sehe. Und: Wir machen wieder nur minimale, gezielte Patches, damit nichts verloren geht.

Dein Dashboard basiert nicht auf der Excel, sondern auf der SQLâ€‘Tabelle CompletedToday.
Das ist perfekt â€” und wir mÃ¼ssen nur ein einziges Feld ergÃ¤nzen und zwei Stellen patchen, damit das Dashboard kÃ¼nftig (KÃ¼rzel + Startâ€‘BFT) getrennt anzeigen kann.

ğŸ§± Was wir brauchen, damit das Dashboard tagesscharf wird
1) Die Tabelle CompletedToday muss ein Feld start_bft bekommen
Sonst kann das Dashboard nicht unterscheiden:

CPâ€‘BFTIV (02.02.)

CPâ€‘BFTIV (03.02.)

2) Die Logistik muss beim Abschluss start_bft mitspeichern
Du hast bereits mark_as_completed(kuerzel).
Wir erweitern sie minimal zu:

Code
mark_as_completed(kuerzel, start_bft)
3) Das Dashboard zeigt dann jede Kombination getrennt an
Und sortiert alphabetisch + Datum.

ğŸ§± Schritt 1 â€” Datenbankmodell erweitern (minimal)
In backend/database.py:

PATCH: Feld ergÃ¤nzen
python
class CompletedToday(Base):
    __tablename__ = "completed_today"

    id = Column(Integer, primary_key=True, index=True)
    kuerzel = Column(String, index=True)
    menge = Column(Integer)
    zielort = Column(String)
    typ = Column(String)
    timestamp = Column(DateTime)
    start_bft = Column(String)   # â† NEU
Migration (einmalig):
sql
ALTER TABLE completed_today ADD COLUMN start_bft TEXT;
ğŸ§± Schritt 2 â€” mark_as_completed() erweitern
In deiner Logistikâ€‘Ãœbersicht rufst du:

python
mark_as_completed(kuerzel)
Wir Ã¤ndern das zu:

python
mark_as_completed(kuerzel, start_bft)
Und die Funktion selbst:

python
def mark_as_completed(kuerzel: str, start_bft: str):
    db = SessionLocal()
    entry = CompletedToday(
        kuerzel=kuerzel,
        menge=0,
        zielort="",
        typ="",
        timestamp=datetime.now(),
        start_bft=start_bft
    )
    db.add(entry)
    db.commit()
    db.close()
ğŸ§± Schritt 3 â€” Dashboard minimal patchen
Dein aktuelles Dashboard:

python
entries = db.query(CompletedToday).order_by(CompletedToday.timestamp.desc()).all()
Das bleibt â€” aber wir mÃ¼ssen die Anzeige erweitern.

PATCH: Templateâ€‘Daten erweitern
Ersetze:

python
"entries": entries
durch:

python
"entries": sorted(entries, key=lambda e: (e.kuerzel, e.start_bft or "", e.timestamp))
Damit sortierst du:

alphabetisch nach KÃ¼rzel

dann chronologisch nach Startâ€‘BFT

dann nach Abschlusszeit

Fertiger Block:
python
@router.get("/")
def dashboard(request: Request):
    db = SessionLocal()
    entries = db.query(CompletedToday).order_by(CompletedToday.timestamp.desc()).all()
    db.close()

    entries = sorted(entries, key=lambda e: (e.kuerzel, e.start_bft or "", e.timestamp))

    return request.app.state.templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "entries": entries
        }
    )
ğŸ§± Schritt 4 â€” Dashboardâ€‘HTML minimal erweitern
Du musst nur eine Zeile ergÃ¤nzen:

Vorher:
Code
{{ entry.kuerzel }}
Nachher:
Code
{{ entry.kuerzel }} â€“ Start: {{ entry.start_bft }}
Damit sieht man:

CPâ€‘BFTIV â€“ Start: 2026â€‘02â€‘02

CPâ€‘BFTIV â€“ Start: 2026â€‘02â€‘03

als zwei getrennte EintrÃ¤ge.

ğŸ‰ Ergebnis
Nach diesen minimalen Patches:

Dashboard zeigt jede Kombination aus KÃ¼rzel + Datum getrennt.

Wenn gestern und heute ein Auftrag abgeschlossen wird â†’ beide sichtbar.

Produktion & Logistik bleiben tagesscharf.

Dashboard bleibt tagesbasiert, aber nicht mehr blind fÃ¼r mehrere Tage.

Keine Logik geht verloren.

Keine Datei wird Ã¼berschrieben.

Alles bleibt narrensicher.

Wenn du willst, kann ich dir jetzt die angepasste mark_as_completed() aus deiner Logistikâ€‘Datei patchen, damit sie start_bft korrekt Ã¼bergibt.